# MARDM 关节点坐标表示方式说明

## ✅ 核心结论

**MARDM生成的NPY文件中，关节点是以世界坐标系的XYZ坐标（笛卡尔坐标）表示的，而不是轴角（Axis-Angle）或旋转表示。**

---

## 📊 数据格式

### NPY文件结构

```python
形状: (seq_len, 22, 3)
      ↓        ↓   ↓
      帧数   关节点 XYZ坐标
```

### 实际数据示例

```
关节点ID | X坐标 (米) | Y坐标 (米) | Z坐标 (米) | 说明
---------|-----------|-----------|-----------|------
   0     |   0.0000  |   0.9394  |   0.0000  | 骨盆
   1     |   0.0632  |   0.8582  |   0.0012  | 右髋
   2     |  -0.0666  |   0.8524  |   0.0026  | 左髋
   3     |  -0.0028  |   1.0649  |  -0.0414  | 脊柱1
   ...   |   ...     |   ...     |   ...     | ...
```

**数值范围**: 约 -2米 到 +2米（合理的人体尺度）

---

## 🔄 两种常见的关节点表示方式对比

### 1️⃣ 世界坐标表示（MARDM使用的方式）✅

**格式**: 每个关节点 = `(X, Y, Z)` 坐标

**特点**:
- ✅ 直观易懂
- ✅ 可以直接用于可视化
- ✅ 适合计算关节点之间的距离
- ✅ 不需要父子关系即可表示位置
- ❌ 数据量较大（22个关节点 × 3维 = 66个数值/帧）

**示例**:
```python
# 第0帧的数据
frame_0 = [
    [0.0000, 0.9394, 0.0000],  # 关节点0: 骨盆
    [0.0632, 0.8582, 0.0012],  # 关节点1: 右髋
    [-0.0666, 0.8524, 0.0026], # 关节点2: 左髋
    # ... 更多关节点
]
```

**使用场景**:
- 3D可视化
- 动作识别
- 姿态估计
- 运动分析

---

### 2️⃣ 轴角/旋转表示（MARDM不使用）❌

**格式**: 根关节 + 相对旋转

**特点**:
- ✅ 数据量小
- ✅ 符合骨骼层级结构
- ✅ 易于施加物理约束
- ❌ 需要正向运动学（FK）计算才能得到世界坐标
- ❌ 不直观

**示例**:
```python
# 轴角表示（MARDM不使用这种格式）
skeleton = {
    'root_position': [0.0, 0.9394, 0.0],  # 根节点位置
    'joint_rotations': [
        [0.1, 0.2, 0.3],  # 关节0的旋转（轴角）
        [0.0, 0.1, 0.0],  # 关节1的旋转
        # ... 更多旋转
    ]
}
```

**使用场景**:
- 角色动画（游戏、电影）
- BVH文件格式
- 物理仿真

---

## 🔍 如何验证数据格式

### 方法1: 检查数值范围

```python
import numpy as np

data = np.load('motion.npy')
print(f"数值范围: [{data.min():.2f}, {data.max():.2f}]")

# 如果是XYZ坐标：数值范围约 -2 到 +2 米（合理）
# 如果是轴角：数值范围约 -π 到 +π 弧度（约 -3.14 到 +3.14）
```

**输出**:
```
数值范围: [-0.69, 1.95]  ✅ 符合世界坐标（米）
```

### 方法2: 检查关节点间距离

```python
import numpy as np

data = np.load('motion.npy')

# 计算骨盆(0)到头部(15)的距离
pelvis = data[0, 0, :]
head = data[0, 15, :]
distance = np.linalg.norm(head - pelvis)

print(f"骨盆到头部距离: {distance:.3f} 米")

# 如果是XYZ坐标：距离约 0.5-0.8米（合理的躯干长度）
# 如果是轴角：这个计算没有意义
```

**输出**:
```
骨盆到头部距离: 0.687 米  ✅ 合理的人体尺度
```

### 方法3: 检查Y轴（高度）值

```python
import numpy as np

data = np.load('motion.npy')

# 检查所有关节点的高度
heights = data[0, :, 1]  # Y轴是高度
print(f"最低点: {heights.min():.3f} 米")
print(f"最高点: {heights.max():.3f} 米")

# 如果是XYZ坐标：高度应该都是正值（站在地面上）
# 如果是轴角：Y值可能是负数（旋转角度）
```

**输出**:
```
最低点: 0.088 米  ✅ 脚部高度
最高点: 1.951 米  ✅ 手臂举起的高度
```

---

## 🎯 MARDM的数据流程

### 完整流程

```
文本提示词
    ↓
CLIP文本编码
    ↓
MARDM扩散模型生成
    ↓
潜在表示 (Latent)
    ↓
AutoEncoder解码
    ↓
压缩特征表示 (67维)
    ↓
反归一化 (× std + mean)
    ↓
recover_from_ric() 函数
    ↓
世界坐标XYZ (22个关节点 × 3维)  ← 最终输出到NPY文件
    ↓
可视化 (plot_3d_motion)
```

### 关键转换步骤

在 `sample.py` 中的关键代码：

```python
# 1. 模型生成压缩特征
pred_motions = ae.decode(pred_latents)  # 形状: (batch, seq_len, 67)

# 2. 反归一化
data = pred_motions * std + mean

# 3. 从RIC表示恢复为XYZ坐标
joint = recover_from_ric(torch.from_numpy(joint_data).float(), nb_joints).numpy()
# 输出形状: (seq_len, 22, 3)  ← 这就是XYZ坐标！

# 4. 保存为NPY文件
np.save('motion.npy', joint)
```

---

## 📐 坐标系说明

### 世界坐标系

```
        Y (上)
        ↑
        |
        |
        o-----→ X (右)
       /
      /
     ↓
    Z (前)
```

- **X轴**: 左右方向（正方向 = 向右）
- **Y轴**: 上下方向（正方向 = 向上）
- **Z轴**: 前后方向（正方向 = 向前）

### 单位

- **单位**: 米（meter）
- **参考**: 成年人身高约 1.7 米

### 原点

- **原点**: 通常在地面上，骨盆附近
- **Y=0**: 地面高度
- **骨盆高度**: 约 0.9 米（站立时）

---

## 💡 实际应用示例

### 1. 计算关节点速度

```python
import numpy as np

motion = np.load('motion.npy')

# 计算右手腕(关节点20)的速度
right_wrist = motion[:, 20, :]  # (seq_len, 3)

# 位移 = 当前帧 - 上一帧
displacement = np.diff(right_wrist, axis=0)  # (seq_len-1, 3)

# 速度大小
speed = np.linalg.norm(displacement, axis=1)  # (seq_len-1,)

print(f"右手腕平均速度: {speed.mean():.4f} 米/帧")
print(f"右手腕最大速度: {speed.max():.4f} 米/帧")

# 如果fps=20，转换为米/秒
fps = 20
speed_ms = speed * fps
print(f"右手腕平均速度: {speed_ms.mean():.4f} 米/秒")
```

### 2. 计算双手距离

```python
import numpy as np

motion = np.load('motion.npy')

left_wrist = motion[:, 21, :]   # 左手腕
right_wrist = motion[:, 20, :]  # 右手腕

# 欧氏距离
hand_distance = np.linalg.norm(left_wrist - right_wrist, axis=1)

print(f"双手平均距离: {hand_distance.mean():.3f} 米")
print(f"双手最大距离: {hand_distance.max():.3f} 米")
print(f"双手最小距离: {hand_distance.min():.3f} 米")
```

### 3. 检测跳跃动作

```python
import numpy as np

motion = np.load('motion.npy')

# 骨盆的高度变化
pelvis_height = motion[:, 0, 1]  # Y坐标

# 找到高度峰值
height_diff = np.diff(pelvis_height)
jumps = np.where(height_diff > 0.1)[0]  # 高度突然增加超过10cm

print(f"检测到 {len(jumps)} 次可能的跳跃")
for jump_frame in jumps:
    print(f"  帧 {jump_frame}: 高度从 {pelvis_height[jump_frame]:.3f}m 到 {pelvis_height[jump_frame+1]:.3f}m")
```

### 4. 计算步幅

```python
import numpy as np

motion = np.load('motion.npy')

# 左脚和右脚的XZ位置（忽略高度）
left_foot = motion[:, 11, [0, 2]]   # 关节点11
right_foot = motion[:, 10, [0, 2]]  # 关节点10

# 计算脚的移动距离
left_foot_travel = np.sum(np.linalg.norm(np.diff(left_foot, axis=0), axis=1))
right_foot_travel = np.sum(np.linalg.norm(np.diff(right_foot, axis=0), axis=1))

print(f"左脚移动距离: {left_foot_travel:.3f} 米")
print(f"右脚移动距离: {right_foot_travel:.3f} 米")
print(f"总移动距离: {(left_foot_travel + right_foot_travel)/2:.3f} 米")
```

---

## 🔄 与其他格式的转换

### 从XYZ坐标转换为BVH（需要计算旋转）

```python
# 伪代码示例
def xyz_to_bvh(xyz_coords, kinematic_tree):
    """
    从XYZ坐标计算关节旋转（逆向运动学）
    这是一个复杂的过程，需要：
    1. 计算每个关节的局部旋转
    2. 考虑父子关系
    3. 处理旋转约束
    """
    rotations = []
    for parent, child in kinematic_tree:
        # 计算从父到子的向量
        bone_vector = xyz_coords[child] - xyz_coords[parent]
        # 计算旋转（需要复杂的数学）
        rotation = compute_rotation(bone_vector)
        rotations.append(rotation)
    return rotations
```

### 从XYZ坐标转换为SMPL参数

```python
# 需要使用专门的库，如 smplx
import smplx

# 这需要优化过程来拟合SMPL模型到关节点
# 通常使用最小二乘法或梯度下降
```

---

## 🆚 对比总结表

| 特性 | XYZ坐标（MARDM使用）✅ | 轴角/旋转表示 |
|------|---------------------|-------------|
| **直观性** | ✅ 非常直观 | ❌ 需要理解旋转 |
| **可视化** | ✅ 直接绘制 | ❌ 需要FK计算 |
| **数据量** | ❌ 较大（66个数/帧） | ✅ 较小（约24个数/帧） |
| **距离计算** | ✅ 直接计算 | ❌ 需要先转换 |
| **物理约束** | ❌ 难以施加 | ✅ 容易施加 |
| **层级结构** | ❌ 不体现 | ✅ 自然体现 |
| **适用场景** | 姿态估计、动作识别 | 角色动画、游戏 |

---

## 📚 相关概念

### 1. RIC表示（MARDM内部使用）

**RIC** = Root-relative, Inverse Kinematics, Coordinate

- 这是MARDM内部使用的压缩表示（67维）
- 包含：根节点旋转速度、位置、高度、局部关节位置等
- 通过 `recover_from_ric()` 函数转换为XYZ坐标

### 2. 正向运动学（FK）

从旋转表示计算XYZ坐标的过程：
```
关节旋转 → FK → XYZ坐标
```

### 3. 逆向运动学（IK）

从XYZ坐标计算旋转的过程（更复杂）：
```
XYZ坐标 → IK → 关节旋转
```

---

## ❓ 常见问题

### Q1: 为什么MARDM使用XYZ坐标而不是旋转？

**A**: 
1. 训练数据（HumanML3D）就是XYZ格式
2. 更容易与姿态估计模型对接
3. 简化了模型架构
4. 更适合扩散模型的生成过程

### Q2: 如何转换为游戏引擎可用的格式？

**A**: 需要：
1. 计算关节旋转（IK）
2. 导出为BVH或FBX格式
3. 使用工具如Blender进行转换

### Q3: 数据中的坐标是相对的还是绝对的？

**A**: 
- 保存的NPY文件中是**绝对世界坐标**
- 但在可视化时会转换为相对坐标（让人物始终在画面中心）

### Q4: 为什么有些Y值（高度）是负数？

**A**: 
- 通常不应该出现负数（地面是Y=0）
- 如果出现，可能是：
  - 数据归一化问题
  - 脚部穿过地面（生成质量问题）
  - 坐标系定义不同

---

## 🔗 相关代码

1. **`utils/motion_process.py`** - `recover_from_ric()` 函数（第83-98行）
2. **`sample.py`** - 数据生成和转换（第116-126行）
3. **`utils/motion_process.py`** - `plot_3d_motion()` 可视化（第103-186行）

---

## 📝 总结

✅ **MARDM生成的NPY文件使用XYZ笛卡尔坐标表示关节点位置**

- 格式: `(seq_len, 22, 3)` - 每个关节点是 `(X, Y, Z)` 坐标
- 单位: 米（meter）
- 坐标系: 世界坐标系（绝对位置）
- 不是: 轴角、旋转矩阵、四元数等旋转表示

这种表示方式直观、易于理解和可视化，非常适合动作生成和分析任务！🎯

